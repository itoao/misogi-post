'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const getStoreType = (store) => {
  return {
    actionContext: {},
    rootState: {},
    rootGetters: {},
    storeInstance: {}
  };
};

const actionTree = (_store, tree) => tree;

const getterTree = (_state, tree) => tree;

const mutationTree = (_state, tree) => tree;

const getAccessorType = (store) => {
  return {};
};
const getNestedState = (parent, namespaces) => {
  if (!parent[namespaces[0]]) {
    return parent;
  } else {
    return getNestedState(parent[namespaces[0]], namespaces.slice(1));
  }
};
const createAccessor = (store, {
  getters,
  state,
  mutations,
  actions,
  namespaced
}, namespace = "") => {
  const namespacedPath = namespace && namespaced ? `${namespace}/` : "";
  const accessor = {};
  Object.keys(getters || {}).forEach((getter) => {
    Object.defineProperty(accessor, getter, {
      get: () => store.getters[`${namespacedPath}${getter}`]
    });
  });
  const evaluatedState = state ? typeof state === "function" ? state() : state : {};
  Object.keys(evaluatedState).forEach((prop) => {
    if (!Object.getOwnPropertyNames(accessor).includes(prop)) {
      const namespaces = namespace.split("/");
      Object.defineProperty(accessor, prop, {
        get: () => getNestedState(store.state, namespaces)[prop]
      });
    }
  });
  Object.keys(mutations || {}).forEach((mutation) => {
    accessor[mutation] = (mutationPayload) => store.commit(`${namespacedPath}${mutation}`, mutationPayload);
  });
  Object.keys(actions || {}).forEach((action) => {
    accessor[action] = (actionPayload) => store.dispatch(`${namespacedPath}${action}`, actionPayload);
  });
  return accessor;
};
const useAccessor = (store, input, namespace) => {
  const accessor = createAccessor(store, input, namespace);
  Object.keys(input.modules || {}).forEach((moduleNamespace) => {
    const nestedNamespace = namespace ? `${namespace}/${moduleNamespace}` : moduleNamespace;
    accessor[moduleNamespace] = useAccessor(store, input.modules[moduleNamespace], nestedNamespace);
  });
  return accessor;
};
const getAccessorFromStore = (pattern) => {
  return (store) => useAccessor(store, pattern._modules.root._rawModule);
};

exports.actionTree = actionTree;
exports.getAccessorFromStore = getAccessorFromStore;
exports.getAccessorType = getAccessorType;
exports.getStoreType = getStoreType;
exports.getterTree = getterTree;
exports.mutationTree = mutationTree;
exports.useAccessor = useAccessor;
