import {
  __commonJS,
  __require,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-EKEEXRHX.mjs";

// node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = __spreadProps(__spreadValues({}, POSIX_CHARS), {
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    });
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = __require("path");
    var win322 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win322 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = __spreadValues({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win322);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = __spreadProps(__spreadValues({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t4 of toks) {
              state.output += t4.output || t4.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = __spreadValues({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win322);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse3;
  }
});

// node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var scan = require_scan();
    var parse3 = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix2 = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = __spreadProps(__spreadValues({}, options), { ignore: null, onMatch: null, onResult: null });
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
        const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix2);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix2 = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse3(pattern, __spreadProps(__spreadValues({}, options), { fastpaths: false }));
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/.pnpm/@antfu+utils@0.3.0/node_modules/@antfu/utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@antfu+utils@0.3.0/node_modules/@antfu/utils/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
    }
    function sum(...args) {
      return flattenArrayable(args).reduce((a, b) => a + b, 0);
    }
    function toArray(array) {
      array = array || [];
      if (Array.isArray(array))
        return array;
      return [array];
    }
    function flattenArrayable(array) {
      return toArray(array).flat(1);
    }
    function mergeArrayable(...args) {
      return args.flatMap((i) => toArray(i));
    }
    function partition2(array, ...filters) {
      const result = new Array(filters.length + 1).fill(null).map(() => []);
      array.forEach((e, idx, arr) => {
        let i = 0;
        for (const filter of filters) {
          if (filter(e, idx, arr)) {
            result[i].push(e);
            return;
          }
          i += 1;
        }
        result[i].push(e);
      });
      return result;
    }
    function uniq(array) {
      return Array.from(new Set(array));
    }
    function last(array) {
      return at(array, -1);
    }
    function remove(array, value) {
      if (!array)
        return false;
      const index = array.indexOf(value);
      if (index >= 0) {
        array.splice(index, 1);
        return true;
      }
      return false;
    }
    function at(array, index) {
      const len = array.length;
      if (!len)
        return void 0;
      if (index < 0)
        index += len;
      return array[index];
    }
    function range(...args) {
      let start, stop, step;
      if (args.length === 1) {
        start = 0;
        step = 1;
        [stop] = args;
      } else {
        [start, stop, step = 1] = args;
      }
      const arr = [];
      let current = start;
      while (current < stop) {
        arr.push(current);
        current += step || 1;
      }
      return arr;
    }
    function move(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
      return arr;
    }
    function clampArrayRange(n, arr) {
      return clamp(n, 0, arr.length - 1);
    }
    var assert = (condition, message) => {
      if (!condition)
        throw new Error(message);
    };
    var toString2 = (v) => Object.prototype.toString.call(v);
    var noop = () => {
    };
    function notNullish(v) {
      return v != null;
    }
    function noNull(v) {
      return v !== null;
    }
    function notUndefined(v) {
      return v !== void 0;
    }
    function isTruthy(v) {
      return Boolean(v);
    }
    var isBrowser = typeof window !== "undefined";
    var isDef = (val) => typeof val !== "undefined";
    var isBoolean = (val) => typeof val === "boolean";
    var isFunction = (val) => typeof val === "function";
    var isNumber = (val) => typeof val === "number";
    var isString = (val) => typeof val === "string";
    var isObject = (val) => toString.call(val) === "[object Object]";
    var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
    function slash(str) {
      return str.replace(/\\/g, "/");
    }
    function ensurePrefix(prefix, str) {
      if (!str.startsWith(prefix))
        return prefix + str;
      return str;
    }
    function template(str, ...args) {
      return str.replace(/{(\d+)}/g, (match, key) => {
        const index = Number(key);
        if (Number.isNaN(index))
          return match;
        return args[index];
      });
    }
    var timestamp = () => +Date.now();
    function batchInvoke(functions) {
      functions.forEach((fn) => fn && fn());
    }
    function invoke(fn) {
      return fn();
    }
    function tap(value, callback) {
      callback(value);
      return value;
    }
    function objectMap(obj, fn) {
      return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));
    }
    function isKeyOf(obj, k) {
      return k in obj;
    }
    function objectKeys(obj) {
      return Object.keys(obj);
    }
    function objectEntries(obj) {
      return Object.entries(obj);
    }
    function deepMerge(target, ...sources) {
      if (!sources.length)
        return target;
      const source = sources.shift();
      if (source === void 0)
        return target;
      if (isMergableObject(target) && isMergableObject(source)) {
        objectKeys(source).forEach((key) => {
          if (isMergableObject(source[key])) {
            if (!target[key])
              target[key] = {};
            deepMerge(target[key], source[key]);
          } else {
            target[key] = source[key];
          }
        });
      }
      return deepMerge(target, ...sources);
    }
    function isMergableObject(item) {
      return isObject(item) && !Array.isArray(item);
    }
    function objectPick(obj, keys, omitUndefined = false) {
      return keys.reduce((n, k) => {
        if (k in obj) {
          if (!omitUndefined || !obj[k] === void 0)
            n[k] = obj[k];
        }
        return n;
      }, {});
    }
    function clearUndefined(obj) {
      Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
      return obj;
    }
    function hasOwnProperty(obj, v) {
      if (obj == null)
        return false;
      return Object.prototype.hasOwnProperty.call(obj, v);
    }
    function createSingletonPromise(fn) {
      let _promise;
      function wrapper() {
        if (!_promise)
          _promise = fn();
        return _promise;
      }
      wrapper.reset = async () => {
        const _prev = _promise;
        _promise = void 0;
        if (_prev)
          await _prev;
      };
      return wrapper;
    }
    function sleep(ms, callback) {
      return new Promise((resolve2) => setTimeout(async () => {
        await (callback == null ? void 0 : callback());
        resolve2();
      }, ms));
    }
    function createPromiseLock() {
      const locks = [];
      return {
        async run(fn) {
          const p = fn();
          locks.push(p);
          try {
            return await p;
          } finally {
            remove(locks, p);
          }
        },
        async wait() {
          await Promise.allSettled(locks);
        },
        isWaiting() {
          return Boolean(locks.length);
        },
        clear() {
          locks.length = 0;
        }
      };
    }
    function throttle(delay, noTrailing, callback, debounceMode) {
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel() {
        clearExistingTimeout();
        cancelled = true;
      }
      if (typeof noTrailing !== "boolean") {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = void 0;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec() {
          lastExec = Date.now();
          callback.apply(self, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (debounceMode && !timeoutID) {
          exec();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          exec();
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce(delay, atBegin, callback) {
      return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
    }
    exports.assert = assert;
    exports.at = at;
    exports.batchInvoke = batchInvoke;
    exports.clamp = clamp;
    exports.clampArrayRange = clampArrayRange;
    exports.clearUndefined = clearUndefined;
    exports.createPromiseLock = createPromiseLock;
    exports.createSingletonPromise = createSingletonPromise;
    exports.debounce = debounce;
    exports.deepMerge = deepMerge;
    exports.ensurePrefix = ensurePrefix;
    exports.flattenArrayable = flattenArrayable;
    exports.hasOwnProperty = hasOwnProperty;
    exports.invoke = invoke;
    exports.isBoolean = isBoolean;
    exports.isBrowser = isBrowser;
    exports.isDef = isDef;
    exports.isFunction = isFunction;
    exports.isKeyOf = isKeyOf;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isString = isString;
    exports.isTruthy = isTruthy;
    exports.isWindow = isWindow;
    exports.last = last;
    exports.mergeArrayable = mergeArrayable;
    exports.move = move;
    exports.noNull = noNull;
    exports.noop = noop;
    exports.notNullish = notNullish;
    exports.notUndefined = notUndefined;
    exports.objectEntries = objectEntries;
    exports.objectKeys = objectKeys;
    exports.objectMap = objectMap;
    exports.objectPick = objectPick;
    exports.partition = partition2;
    exports.range = range;
    exports.remove = remove;
    exports.slash = slash;
    exports.sleep = sleep;
    exports.sum = sum;
    exports.tap = tap;
    exports.template = template;
    exports.throttle = throttle;
    exports.timestamp = timestamp;
    exports.toArray = toArray;
    exports.toString = toString2;
    exports.uniq = uniq;
  }
});

// src/index.ts
import { createUnplugin } from "unplugin";

// node_modules/.pnpm/@rollup+pluginutils@4.1.1/node_modules/@rollup/pluginutils/dist/es/index.js
var import_picomatch = __toModule(require_picomatch2());
import { extname, win32, posix, isAbsolute, resolve } from "path";
function isArray(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
var normalizePath = function normalizePath2(filename) {
  return filename.split(win32.sep).join(posix.sep);
};
function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false || isAbsolute(id) || id.startsWith("*")) {
    return id;
  }
  const basePath = normalizePath(resolve(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return posix.join(basePath, id);
}
var createFilter = function createFilter2(include, exclude, options) {
  const resolutionBase = options && options.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern = getMatcherString(id, resolutionBase);
      const fn = (0, import_picomatch.default)(pattern, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = normalizePath(id);
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (matcher.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (matcher.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(" "));
forbiddenIdentifiers.add("");

// src/core/transform.ts
import MagicString2 from "magic-string";
import { shouldTransform as shouldTransformRefSugar, transform as transformRef } from "@vue/ref-transform";

// src/core/parseSFC.ts
import { Parser as HTMLParser } from "htmlparser2";
import { parse } from "@babel/parser";
import { camelize, capitalize, isHTMLTag, isSVGTag, isVoidTag } from "@vue/shared";

// src/core/identifiers.ts
function getIdentifierDeclarations(nodes, identifiers = new Set()) {
  for (let node of nodes) {
    if (node.type === "ExportNamedDeclaration") {
      node = node.declaration;
      if (!node)
        continue;
    }
    if (node.type === "ImportDeclaration") {
      for (const specifier of node.specifiers)
        identifiers.add(specifier.local.name);
    } else if (node.type === "VariableDeclaration") {
      let handleVariableId = function(node2) {
        if (node2.type === "Identifier") {
          identifiers.add(node2.name);
        } else if (node2.type === "ObjectPattern") {
          for (const property of node2.properties) {
            if (property.type === "ObjectProperty")
              handleVariableId(property.value);
            else if (property.type === "RestElement" && property.argument.type === "Identifier")
              identifiers.add(property.argument.name);
          }
        } else if (node2.type === "ArrayPattern") {
          for (const element of node2.elements) {
            if ((element == null ? void 0 : element.type) === "Identifier")
              identifiers.add(element.name);
            else if ((element == null ? void 0 : element.type) === "RestElement" && element.argument.type === "Identifier")
              identifiers.add(element.argument.name);
            else if ((element == null ? void 0 : element.type) === "ObjectPattern" || (element == null ? void 0 : element.type) === "ArrayPattern")
              handleVariableId(element);
          }
        }
      };
      for (const declarator of node.declarations)
        handleVariableId(declarator.id);
    } else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
      if (node.id)
        identifiers.add(node.id.name);
    } else if (node.type === "TSEnumDeclaration") {
      if (node.id)
        identifiers.add(node.id.name);
    }
  }
  return identifiers;
}
function getIdentifierUsages(node, identifiers = new Set()) {
  if (!node)
    return identifiers;
  if (node.type === "BlockStatement") {
    node.body.forEach((child) => getIdentifierUsages(child, identifiers));
  } else if (node.type === "ExpressionStatement") {
    getIdentifierUsages(node.expression, identifiers);
  } else if (node.type === "Identifier") {
    identifiers.add(node.name);
  } else if (node.type === "MemberExpression") {
    getIdentifierUsages(node.object, identifiers);
  } else if (node.type === "CallExpression") {
    getIdentifierUsages(node.callee, identifiers);
    node.arguments.forEach((arg) => getIdentifierUsages(arg, identifiers));
  } else if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
    getIdentifierUsages(node.left, identifiers);
    getIdentifierUsages(node.right, identifiers);
  } else if (node.type === "UnaryExpression") {
    getIdentifierUsages(node.argument, identifiers);
  } else if (node.type === "ForOfStatement" || node.type === "ForInStatement") {
    getIdentifierUsages(node.right, identifiers);
  } else if (node.type === "ConditionalExpression") {
    getIdentifierUsages(node.test, identifiers);
    getIdentifierUsages(node.consequent, identifiers);
    getIdentifierUsages(node.alternate, identifiers);
  } else if (node.type === "ObjectExpression") {
    node.properties.forEach((prop) => {
      if (prop.type === "ObjectProperty") {
        if (prop.computed)
          getIdentifierUsages(prop.key, identifiers);
        getIdentifierUsages(prop.value, identifiers);
      } else if (prop.type === "SpreadElement") {
        getIdentifierUsages(prop, identifiers);
      }
    });
  } else if (node.type === "ArrayExpression") {
    node.elements.forEach((element) => getIdentifierUsages(element, identifiers));
  } else if (node.type === "SpreadElement" || node.type === "ReturnStatement") {
    getIdentifierUsages(node.argument, identifiers);
  } else if (node.type === "NewExpression") {
    getIdentifierUsages(node.callee, identifiers);
    node.arguments.forEach((arg) => getIdentifierUsages(arg, identifiers));
  } else if (node.type === "ArrowFunctionExpression" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
    getIdentifierUsages(node.body, identifiers);
  } else if (node.type === "TemplateLiteral") {
    node.expressions.forEach((expr) => getIdentifierUsages(expr, identifiers));
  }
  return identifiers;
}

// src/core/parseSFC.ts
function parseSFC(code, id, options) {
  var _a, _b, _c, _d;
  const components = new Set();
  const expressions = new Set();
  const identifiers = new Set();
  let templateLevel = 0;
  let inScriptSetup = false;
  let inScript = false;
  const scriptSetup = {
    start: 0,
    end: 0,
    contentStart: 0,
    contentEnd: 0,
    content: "",
    attrs: {},
    found: false,
    ast: void 0
  };
  const script = {
    start: 0,
    end: 0,
    contentStart: 0,
    contentEnd: 0,
    content: "",
    attrs: {},
    found: false,
    ast: void 0
  };
  const parser = new HTMLParser({
    onopentag(name, attributes) {
      if (!name)
        return;
      if (name === "template")
        templateLevel += 1;
      if (templateLevel > 0) {
        if (!isHTMLTag(name) && !isSVGTag(name) && !isVoidTag(name))
          components.add(capitalize(camelize(name)));
        Object.entries(attributes).forEach(([key, value]) => {
          if (!value)
            return;
          if (key.startsWith("v-") || key.startsWith("@") || key.startsWith(":")) {
            if (key === "v-for")
              expressions.add(`(${value.replace(/^.*\s(?:in|of)\s/, "")})`);
            else
              expressions.add(`(${value})`);
          }
          if (key === "ref")
            identifiers.add(value);
        });
      } else {
        if (name === "script") {
          if ("setup" in attributes) {
            scriptSetup.start = parser.startIndex;
            scriptSetup.contentStart = parser.endIndex + 1;
            scriptSetup.attrs = attributes;
            scriptSetup.found = true;
            inScriptSetup = true;
          } else {
            script.start = parser.startIndex;
            script.contentStart = parser.endIndex + 1;
            script.attrs = attributes;
            script.found = true;
            inScript = true;
          }
        }
      }
    },
    ontext(text) {
      if (templateLevel > 0) {
        Array.from(text.matchAll(/\{\{(.*?)\}\}/g)).forEach(([, expression]) => {
          expressions.add(`(${expression})`);
        });
      }
    },
    onclosetag(name) {
      if (name === "template")
        templateLevel -= 1;
      if (inScriptSetup && name === "script") {
        scriptSetup.end = parser.endIndex + 1;
        scriptSetup.contentEnd = parser.startIndex;
        scriptSetup.content = code.slice(scriptSetup.contentStart, scriptSetup.contentEnd);
        inScriptSetup = false;
      }
      if (inScript && name === "script") {
        script.end = parser.endIndex + 1;
        script.contentEnd = parser.startIndex;
        script.content = code.slice(script.contentStart, script.contentEnd);
        inScript = false;
      }
    }
  }, {
    xmlMode: true,
    lowerCaseTags: false,
    lowerCaseAttributeNames: false,
    recognizeSelfClosing: true
  });
  parser.write(code);
  parser.end();
  expressions.forEach((exp) => {
    const nodes = parse(exp).program.body;
    nodes.forEach((node) => getIdentifierUsages(node, identifiers));
  });
  if (script.found && scriptSetup.found && scriptSetup.attrs.lang !== script.attrs.lang)
    throw new SyntaxError("<script setup> language must be the same as <script>");
  const parserOptions = {
    sourceType: "module",
    plugins: []
  };
  const lang = scriptSetup.attrs.lang || script.attrs.lang || "js";
  if (lang === "ts")
    parserOptions.plugins.push("typescript");
  else if (lang === "jsx")
    parserOptions.plugins.push("jsx");
  else if (lang === "tsx")
    parserOptions.plugins.push("typescript", "jsx");
  else if (lang !== "js")
    throw new SyntaxError(`Unsupported script language: ${lang}`);
  scriptSetup.ast = parse(scriptSetup.content, parserOptions).program;
  script.ast = parse(script.content || "", parserOptions).program;
  scriptSetup.ast = ((_b = (_a = options == null ? void 0 : options.astTransforms) == null ? void 0 : _a.scriptSetup) == null ? void 0 : _b.call(_a, scriptSetup.ast)) || scriptSetup.ast;
  script.ast = ((_d = (_c = options == null ? void 0 : options.astTransforms) == null ? void 0 : _c.script) == null ? void 0 : _d.call(_c, script.ast)) || script.ast;
  return {
    id,
    template: {
      components,
      identifiers
    },
    scriptSetup,
    script,
    parserOptions,
    extraDeclarations: []
  };
}

// src/core/transformScriptSetup.ts
var import_utils = __toModule(require_dist());
import { types as t2 } from "@babel/core";
import { camelize as camelize2, capitalize as capitalize2 } from "@vue/shared";
import generate from "@babel/generator";

// src/core/macros.ts
import { types as t } from "@babel/core";
import { parseExpression } from "@babel/parser";
var DEFINE_PROPS = "defineProps";
var DEFINE_EMITS = "defineEmits";
var DEFINE_EXPOSE = "defineExpose";
var WITH_DEFAULTS = "withDefaults";
function applyMacros(nodes) {
  let hasDefinePropsCall = false;
  let hasDefineEmitCall = false;
  let propsRuntimeDecl;
  let propsRuntimeDefaults;
  let propsTypeDecl;
  let propsTypeDeclRaw;
  let emitsRuntimeDecl;
  let emitsTypeDecl;
  let emitsTypeDeclRaw;
  const typeDeclaredProps = {};
  const declaredTypes = {};
  function error(msg, node) {
    throw new Error(msg);
  }
  function processDefineProps(node) {
    if (!isCallOf(node, DEFINE_PROPS))
      return false;
    if (hasDefinePropsCall)
      error(`duplicate ${DEFINE_PROPS}() call`, node);
    hasDefinePropsCall = true;
    propsRuntimeDecl = node.arguments[0];
    if (node.typeParameters) {
      if (propsRuntimeDecl) {
        error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
      }
      propsTypeDeclRaw = node.typeParameters.params[0];
      propsTypeDecl = resolveQualifiedType(propsTypeDeclRaw, (node2) => node2.type === "TSTypeLiteral");
      if (!propsTypeDecl) {
        error(`type argument passed to ${DEFINE_PROPS}() must be a literal type, or a reference to an interface or literal type.`, propsTypeDeclRaw);
      }
    }
    return true;
  }
  function processWithDefaults(node) {
    if (!isCallOf(node, WITH_DEFAULTS))
      return false;
    if (processDefineProps(node.arguments[0])) {
      if (propsRuntimeDecl) {
        error(`${WITH_DEFAULTS} can only be used with type-based ${DEFINE_PROPS} declaration.`, node);
      }
      propsRuntimeDefaults = node.arguments[1];
    } else {
      error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node.arguments[0] || node);
    }
    return true;
  }
  function processDefineEmits(node) {
    if (!isCallOf(node, DEFINE_EMITS))
      return false;
    if (hasDefineEmitCall)
      error(`duplicate ${DEFINE_EMITS}() call`, node);
    hasDefineEmitCall = true;
    emitsRuntimeDecl = node.arguments[0];
    if (node.typeParameters) {
      if (emitsRuntimeDecl) {
        error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
      }
      emitsTypeDeclRaw = node.typeParameters.params[0];
      emitsTypeDecl = resolveQualifiedType(emitsTypeDeclRaw, (node2) => node2.type === "TSFunctionType" || node2.type === "TSTypeLiteral");
      if (!emitsTypeDecl) {
        error(`type argument passed to ${DEFINE_EMITS}() must be a function type, a literal type with call signatures, or a reference to the above types.`, emitsTypeDeclRaw);
      }
    }
    return true;
  }
  function resolveQualifiedType(node, qualifier) {
    if (qualifier(node))
      return node;
    if (node.type === "TSTypeReference" && node.typeName.type === "Identifier") {
      const refName = node.typeName.name;
      const isQualifiedType = (node2) => {
        if (node2.type === "TSInterfaceDeclaration" && node2.id.name === refName)
          return node2.body;
        else if (node2.type === "TSTypeAliasDeclaration" && node2.id.name === refName && qualifier(node2.typeAnnotation))
          return node2.typeAnnotation;
        else if (node2.type === "ExportNamedDeclaration" && node2.declaration)
          return isQualifiedType(node2.declaration);
      };
      for (const node2 of nodes) {
        const qualified = isQualifiedType(node2);
        if (qualified)
          return qualified;
      }
    }
  }
  function processDefineExpose(node) {
    if (isCallOf(node, DEFINE_EXPOSE))
      error(`Vue 2 does not support ${DEFINE_EXPOSE}()`, node);
    return false;
  }
  function genRuntimeProps(props) {
    const keys = Object.keys(props);
    if (!keys.length)
      return void 0;
    const hasStaticDefaults = propsRuntimeDefaults && propsRuntimeDefaults.type === "ObjectExpression" && propsRuntimeDefaults.properties.every((node) => node.type === "ObjectProperty" && !node.computed);
    return t.objectExpression(Object.entries(props).map(([key, value]) => {
      if (value.type === "null")
        return t.objectProperty(t.identifier(key), t.nullLiteral());
      const prop = hasStaticDefaults ? propsRuntimeDefaults.properties.find((node) => node.key.name === key) : void 0;
      if (prop)
        value.required = false;
      const entries = Object.entries(value).map(([key2, value2]) => key2 === "type" ? t.objectProperty(t.identifier(key2), typeof value2 === "string" ? t.identifier(value2) : t.arrayExpression(value2.map((i) => t.identifier(i)))) : t.objectProperty(t.identifier(key2), parseExpression(JSON.stringify(value2))));
      if (prop)
        entries.push(t.objectProperty(t.identifier("default"), prop.value));
      return t.objectProperty(t.identifier(key), t.objectExpression(entries));
    }));
  }
  function getProps() {
    if (propsRuntimeDecl)
      return propsRuntimeDecl;
    if (propsTypeDecl) {
      extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
      return genRuntimeProps(typeDeclaredProps);
    }
  }
  function throwIfAwait(node) {
    if (node.type === "AwaitExpression")
      error("top-level await is not supported in Vue 2", node);
  }
  nodes = nodes.map((raw) => {
    let node = raw;
    if (raw.type === "ExpressionStatement")
      node = raw.expression;
    if (node.type === "VariableDeclaration" && !node.declare) {
      const total = node.declarations.length;
      for (let i = 0; i < total; i++) {
        const decl = node.declarations[i];
        if (decl.init) {
          if (processDefineEmits(decl.init))
            decl.init = t.memberExpression(t.identifier("__ctx"), t.identifier("emit"));
          else if (processDefineProps(decl.init) || processWithDefaults(decl.init))
            decl.init = t.identifier("__props");
          else
            throwIfAwait(decl.init);
        }
      }
    }
    if (processDefineEmits(node) || processDefineProps(node) || processDefineExpose(node))
      return null;
    throwIfAwait(node);
    return raw;
  }).filter(Boolean);
  return {
    nodes,
    props: getProps()
  };
}
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function extractRuntimeProps(node, props, declaredTypes) {
  const members = node.type === "TSTypeLiteral" ? node.members : node.body;
  for (const m of members) {
    if ((m.type === "TSPropertySignature" || m.type === "TSMethodSignature") && m.key.type === "Identifier") {
      let type;
      if (m.type === "TSMethodSignature") {
        type = ["Function"];
      } else if (m.typeAnnotation) {
        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes);
      }
      props[m.key.name] = {
        key: m.key.name,
        required: !m.optional,
        type: (type == null ? void 0 : type.length) === 1 ? type[0] : type || "null"
      };
    }
  }
}
function inferRuntimeType(node, declaredTypes) {
  switch (node.type) {
    case "TSStringKeyword":
      return ["String"];
    case "TSNumberKeyword":
      return ["Number"];
    case "TSBooleanKeyword":
      return ["Boolean"];
    case "TSObjectKeyword":
      return ["Object"];
    case "TSTypeLiteral":
      return ["Object"];
    case "TSFunctionType":
      return ["Function"];
    case "TSArrayType":
    case "TSTupleType":
      return ["Array"];
    case "TSLiteralType":
      switch (node.literal.type) {
        case "StringLiteral":
          return ["String"];
        case "BooleanLiteral":
          return ["Boolean"];
        case "NumericLiteral":
        case "BigIntLiteral":
          return ["Number"];
        default:
          return ["null"];
      }
    case "TSTypeReference":
      if (node.typeName.type === "Identifier") {
        if (declaredTypes[node.typeName.name])
          return declaredTypes[node.typeName.name];
        switch (node.typeName.name) {
          case "Array":
          case "Function":
          case "Object":
          case "Set":
          case "Map":
          case "WeakSet":
          case "WeakMap":
            return [node.typeName.name];
          case "Record":
          case "Partial":
          case "Readonly":
          case "Pick":
          case "Omit":
          case "Exclude":
          case "Extract":
          case "Required":
          case "InstanceType":
            return ["Object"];
        }
      }
      return ["null"];
    case "TSParenthesizedType":
      return inferRuntimeType(node.typeAnnotation, declaredTypes);
    case "TSUnionType":
      return [
        ...new Set([].concat(...node.types.map((t4) => inferRuntimeType(t4, declaredTypes))))
      ];
    case "TSIntersectionType":
      return ["Object"];
    default:
      return ["null"];
  }
}

// src/core/transformScriptSetup.ts
function transformScriptSetup(sfc, options) {
  var _a, _b;
  const { scriptSetup, script, template } = sfc;
  const { nodes: body, props } = applyMacros(scriptSetup.ast.body);
  const [hoisted, setupBody] = (0, import_utils.partition)(body, (n) => n.type === "ImportDeclaration" || n.type === "ExportNamedDeclaration" || n.type.startsWith("TS"));
  const declarations = new Set();
  getIdentifierDeclarations(hoisted, declarations);
  getIdentifierDeclarations(setupBody, declarations);
  const returns = Array.from(declarations).filter(Boolean).filter((i) => template.identifiers.has(i));
  const components = Array.from(declarations).filter(Boolean).filter((i) => template.components.has(i) || template.components.has(camelize2(i)) || template.components.has(capitalize2(camelize2(i))));
  const __sfc = t2.identifier("__sfc_main");
  let hasBody = false;
  const bodyNodes = script.ast.body.map((node) => {
    if (node.type === "ExportDefaultDeclaration") {
      hasBody = true;
      return t2.variableDeclaration("const", [
        t2.variableDeclarator(__sfc, node.declaration)
      ]);
    }
    return node;
  });
  let ast = t2.program([
    ...sfc.extraDeclarations,
    ...hoisted,
    ...bodyNodes
  ]);
  if (!hasBody) {
    ast.body.push(t2.variableDeclaration("const", [
      t2.variableDeclarator(__sfc, t2.objectExpression([]))
    ]));
  }
  if (props) {
    hasBody = true;
    ast.body.push(t2.expressionStatement(t2.assignmentExpression("=", t2.memberExpression(__sfc, t2.identifier("props")), props)));
  }
  if (body.length) {
    hasBody = true;
    const returnStatement = t2.returnStatement(t2.objectExpression(returns.map((i) => {
      const id = t2.identifier(i);
      return t2.objectProperty(id, id, false, true);
    })));
    ast.body.push(t2.expressionStatement(t2.assignmentExpression("=", t2.memberExpression(__sfc, t2.identifier("setup")), t2.arrowFunctionExpression([
      t2.identifier("__props"),
      t2.identifier("__ctx")
    ], t2.blockStatement([
      ...setupBody,
      returnStatement
    ])))));
  }
  if (components.length) {
    hasBody = true;
    const componentsObject = t2.objectExpression(components.map((i) => {
      const id = t2.identifier(i);
      return t2.objectProperty(id, id, false, true);
    }));
    ast.body.push(t2.expressionStatement(t2.assignmentExpression("=", t2.memberExpression(__sfc, t2.identifier("components")), t2.callExpression(t2.memberExpression(t2.identifier("Object"), t2.identifier("assign")), [
      componentsObject,
      t2.memberExpression(__sfc, t2.identifier("components"))
    ]))));
  }
  if (!hasBody && !(options == null ? void 0 : options.astTransforms)) {
    return {
      ast: null,
      code: ""
    };
  }
  ast.body.push(t2.exportDefaultDeclaration(__sfc));
  ast = ((_b = (_a = options == null ? void 0 : options.astTransforms) == null ? void 0 : _a.post) == null ? void 0 : _b.call(_a, ast, sfc)) || ast;
  return {
    ast,
    code: generate(ast).code
  };
}

// src/core/transformSfcRefSugar.ts
import { shouldTransform, transformAST } from "@vue/ref-transform";
import MagicString from "magic-string";
import { parse as parse2 } from "@babel/parser";
import { types as t3 } from "@babel/core";
function transformSfcRefSugar(sfc, options) {
  const importedHelpers = new Set();
  for (const script of [sfc.script, sfc.scriptSetup]) {
    if (shouldTransform(script.content)) {
      const s = new MagicString(script.content);
      const { importedHelpers: imports } = transformAST(script.ast, s);
      Array.from(imports).forEach((helper) => importedHelpers.add(helper));
      script.content = s.toString();
      script.ast = parse2(script.content, sfc.parserOptions).program;
    }
  }
  if (importedHelpers.size) {
    sfc.extraDeclarations = [
      t3.importDeclaration(Array.from(importedHelpers).map((i) => t3.importSpecifier(t3.identifier(`_${i}`), t3.identifier(i))), t3.stringLiteral(options.importHelpersFrom))
    ];
  }
}

// src/core/options.ts
function resolveOptions(options = {}) {
  return Object.assign({}, {
    sourceMap: true,
    refTransform: false,
    importHelpersFrom: "@vue/composition-api",
    astTransforms: {}
  }, options);
}

// src/core/transform.ts
var scriptSetupRE = /<script\s(.*\s)?setup(\s.*)?>/;
function shouldTransform2(code, id, options) {
  if (code.includes("export default __sfc_main"))
    return false;
  return (options == null ? void 0 : options.refTransform) && shouldTransformRefSugar(code) || scriptSetupRE.test(code);
}
function transform(input, id, options) {
  if (!shouldTransform2(input, id, options))
    return null;
  const resolved = resolveOptions(options);
  if (id.endsWith(".vue") || id.includes(".vue?vue"))
    return transformVue(input, id, resolved);
  else
    return transformNonVue(input, id, resolved);
}
function transformNonVue(input, id, options) {
  if (options.refTransform && shouldTransformRefSugar(input)) {
    return transformRef(input, {
      filename: id,
      sourceMap: options.sourceMap,
      importHelpersFrom: options.importHelpersFrom
    });
  }
  return null;
}
function transformVue(input, id, options) {
  const s = new MagicString2(input);
  const sfc = parseSFC(input, id);
  if (options.refTransform)
    transformSfcRefSugar(sfc, options);
  const { code } = transformScriptSetup(sfc, options);
  const attributes = __spreadValues(__spreadValues({}, sfc.script.attrs), sfc.scriptSetup.attrs);
  delete attributes.setup;
  const attr = Object.entries(attributes).map(([key, value]) => value ? `${key}="${value}"` : key).join(" ");
  if (code) {
    const block = `<script ${attr}>
${code}
<\/script>`;
    s.remove(sfc.script.start, sfc.script.end);
    if (sfc.scriptSetup.start !== sfc.scriptSetup.end) {
      s.overwrite(sfc.scriptSetup.start, sfc.scriptSetup.end, block);
    } else {
      s.prependLeft(0, `${block}
`);
    }
  }
  return {
    code: s.toString(),
    map: options.sourceMap ? s.generateMap() : null
  };
}

// src/index.ts
var src_default = createUnplugin((options = {}) => {
  const filter = createFilter(options.include || (options.refTransform ? [/\.vue$/, /\.vue\?vue/, /\.[jt]sx?$/] : [/\.vue$/, /\.vue\?vue/]), options.exclude || [/node_modules/, /\.git/, /\.nuxt/]);
  return {
    name: "unplugin-vue2-script-setup",
    enforce: "pre",
    transformInclude(id) {
      return filter(id);
    },
    transform(code, id) {
      try {
        return transform(code, id, options);
      } catch (e) {
        this.error(e);
      }
    }
  };
});

export {
  transformScriptSetup,
  shouldTransform2 as shouldTransform,
  transform,
  src_default
};
